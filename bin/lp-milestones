#!/usr/bin/python
#
# Author: Robert Collins <robert.collins@canonical.com>
#
# Copyright 2010 Canonical Ltd.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3, as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import with_statement
import optparse
import os
import sys

# Might want to make errors import lazy.
from bzrlib import commands, errors, ui, version_info as bzr_version_info
from launchpadlib.errors import HTTPError

from lptools import config

def list_commands(command_names):
    mod = sys.modules[__name__]
    command_names.update(commands._scan_module_for_commands(mod))
    return command_names


def get_command(cmd_or_None, cmd_name):
    if cmd_name is None:
        return cmd_help()
    try:
        return globals()['cmd_' + cmd_name]()
    except KeyError:
        return cmd_or_None


class LaunchpadCommand(commands.Command):
    """Base class for commands working with launchpad."""

    def run_argv_aliases(self, argv, alias_argv=None):
        # This might not be unique-enough for a cachedir; can do
        # lp-milestones/cmdname if needed.
        self.launchpad = config.get_launchpad('lp-milestones')
        return commands.Command.run_argv_aliases(self, argv, alias_argv)


class cmd_create(LaunchpadCommand):
    """Create a milestone.
    
    lp-milestone create projectname/seriesname/milestonename
    """

    takes_args = ['milestone']

    def run(self, milestone):
        components = milestone.split('/')
        if len(components) != 3:
            raise errors.BzrCommandError("milestone (%s) too short or too long."
                % milestone)
        projectname, seriesname, milestonename = components
        # Direct access takes 50% of the time of doing traversal.
        #proj = self.launchpad.projects[projectname]
        #series = proj.getSeries(name=seriesname)
        series = self.launchpad.load(projectname + '/' + seriesname)
        milestone = series.newMilestone(name=milestonename)


class cmd_delete(LaunchpadCommand):
    """Delete a milestone.
    
    lp-milestone delete projectname/milestonename
    """

    takes_args = ['milestone']

    def run(self, milestone):
        components = milestone.split('/')
        if len(components) != 2:
            raise errors.BzrCommandError("milestone (%s) too short or too long."
                % milestone)
        m = self.launchpad.load('%s/+milestone/%s' % tuple(components))
        try:
            m.delete()
        except HTTPError, e:
            if e.response.status != 404:
                raise


class cmd_help(commands.Command):
    """Show help on a command or other topic."""

    # Can't use the stock bzrlib help, because the help indices aren't quite
    # generic enough.
    takes_args = ['topic?']
    def run(self, topic=None):
        if topic is None:
            self.outf.write(
"""lp-milestones -- An lptools command to work with milestones in launchpad.
https://launchpad.net/lptools/

lp-milestones help commands -- list commands
""")
        else:
            import bzrlib.help
            bzrlib.help.help(topic)


def do_run_bzr(argv):
    if bzr_version_info > (2, 2, 0):
        # in bzr 2.2 we can disable bzr plugins so bzr commands don't show
        # up.
        return commands.run_bzr(argv, lambda:None, lambda:None)
    else:
        return commands.run_bzr(argv)


def main():
    commands.Command.hooks.install_named_hook('list_commands', list_commands,
        "list")
    commands.Command.hooks.install_named_hook('get_command', get_command,
        "get")
    ui.ui_factory = ui.make_ui_for_terminal(sys.stdin, sys.stdout, sys.stderr)
    sys.exit(commands.exception_to_return_code(do_run_bzr, sys.argv[1:]))

if __name__ == "__main__":
    main()
